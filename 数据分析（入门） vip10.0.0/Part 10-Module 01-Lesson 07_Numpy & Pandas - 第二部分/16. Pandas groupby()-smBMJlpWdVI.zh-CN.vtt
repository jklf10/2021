WEBVTT
Kind: captions
Language: zh-CN

00:00:00.500 --> 00:00:03.060
我就地铁数据提出的许多问题

00:00:03.060 --> 00:00:04.470
都有一些的共同点

00:00:04.470 --> 00:00:08.590
例如 我想知道每天每小时的客流量变化

00:00:08.590 --> 00:00:11.060
但文档含有不同车站

00:00:11.060 --> 00:00:14.890
每天每小时的入站人数

00:00:14.890 --> 00:00:19.560
所以 我先要把数据按照小时分组

00:00:19.560 --> 00:00:25.040
然后 计算每小时的平均客流量 再分析这些数据

00:00:25.040 --> 00:00:29.000
同样地 我想知道降雨是否会影响客流量

00:00:29.000 --> 00:00:31.690
一种方法是 将数据分成两组

00:00:31.690 --> 00:00:34.420
包括降雨和不降雨时的数据

00:00:34.420 --> 00:00:36.995
然后 我将两组的客流量进行比较

00:00:36.995 --> 00:00:40.215
同样地 分组后要进行汇总

00:00:40.215 --> 00:00:42.925
也就是 计算每组的入站总人数

00:00:42.925 --> 00:00:44.895
或者 取每组入站人数的平均值

00:00:46.035 --> 00:00:48.705
我还提到 我想知道在一周中

00:00:48.705 --> 00:00:49.655
客流量每天的变化差异

00:00:49.655 --> 00:00:53.225
我同样需要按星期对数据进行分组 然后计算每天的总和

00:00:53.225 --> 00:00:56.335
这可能会让你想起 第一节课的代码

00:00:56.335 --> 00:01:00.155
我们按账户密码将数据分组 然后计算各账户参与记录的总和

00:01:01.400 --> 00:01:04.715
在第一节课中 我选用名为 group_data 的函数来完成第一步

00:01:04.715 --> 00:01:09.800
并用名为 sum_grouped_items 的函数完成第二步

00:01:09.800 --> 00:01:13.610
Pandas 有类似的内置函数

00:01:13.610 --> 00:01:15.630
使我们可以用极少的代码来完成这类分析

00:01:15.630 --> 00:01:17.710
让我们看一个具体的示例

00:01:17.710 --> 00:01:21.860
假设 Pandas DataFrame已给出各学生的参与数据

00:01:21.860 --> 00:01:24.913
作为例子 我在这里创建了一个小的DataFrame

00:01:24.913 --> 00:01:27.730
要计算上课的平均时间

00:01:27.730 --> 00:01:30.413
我要用的代码是 

00:01:30.413 --> 00:01:35.000
engagement_df.groupyby('account_key').sum()['total_minutes_vi-sited'].mean()

00:01:35.000 --> 00:01:37.918
现在 我们逐个分析这串代码

00:01:37.918 --> 00:01:41.610
首先 通过调用 engagement_df.groupby('account_key')

00:01:41.610 --> 00:01:46.090
可以创建一个名为 DataFrameGroupBy object 的特殊对象 

00:01:46.090 --> 00:01:49.500
我将它视为一种字典

00:01:49.500 --> 00:01:52.830
它映射各账户密码和仅含有与该账户密码相匹配的行的小型 DataFrame

00:01:52.830 --> 00:01:56.760
但事实上 它并不是字典 而是自定义对象

00:01:56.760 --> 00:02:00.720
如有需要 你还可以通过 .groups 属性 查看映射

00:02:00.720 --> 00:02:05.140
它显示 账户密码 1175 

00:02:05.140 --> 00:02:07.150
对应原数据库的第 7 至第 13 行

00:02:07.150 --> 00:02:10.320
而账户密码 1200 对应第 0 至第 6 行

00:02:10.320 --> 00:02:15.700
我们通常不需要直接检查潜在组别

00:02:15.700 --> 00:02:19.120
但有时 了解一下具体情况也是很有帮助的

00:02:19.120 --> 00:02:22.190
接下来 我要对 groupby 对象使用 .sum 函数

00:02:22.190 --> 00:02:24.950
以将各组的每一列相加

00:02:24.950 --> 00:02:28.720
可以看到它的计算结果

00:02:28.720 --> 00:02:30.830
账户密码 1175 访问的总分钟数是 2.7

00:02:30.830 --> 00:02:35.001
而账户密码 1200 访问的总分钟数是 696.6

00:02:35.001 --> 00:02:38.276
注意 输出结果中不含日期列

00:02:38.276 --> 00:02:40.700
因为 我们无法计算日期的总和 DataFrame

00:02:40.700 --> 00:02:43.120
但如果 DataFrame 中有其它的值列

00:02:43.120 --> 00:02:44.290
那么 输出结果也会含有相应的列

00:02:45.530 --> 00:02:49.910
当我加上 total_minutes_visited 时 我得到了同样的数据

00:02:49.910 --> 00:02:51.860
但这次它是以 PandasSeries 的形式呈现的

00:02:51.860 --> 00:02:55.180
注意 此前 它是在仅有一列的 DataFrame 中

00:02:55.180 --> 00:02:58.930
因为 它在 IPython Notebook 中是作为表格输出的

00:02:58.930 --> 00:03:02.362
同样地 若 DataFrame 中有其它值列 则这个 DataFrame 也会含有相应的列

00:03:02.362 --> 00:03:06.280
但这一系列数仅含有 total_minutes_visited 一列

00:03:06.280 --> 00:03:10.584
现在 我想计算所有学生的平均值

00:03:10.584 --> 00:03:15.570
所以 我加上 .mean 从而获得单值 两人的平均值约为 250

00:03:15.570 --> 00:03:19.050
或者 我可以用 describe 函数

00:03:19.050 --> 00:03:21.400
获得一些度量指标 包括平均值

00:03:21.400 --> 00:03:24.770
标准偏差、最小值和最大值

00:03:24.770 --> 00:03:28.190
我在初次学习 groupby 时发现

00:03:28.190 --> 00:03:31.190
sum 函数这个代码比较难理解

00:03:31.190 --> 00:03:34.820
之前 DataFrame 大家已经了解了 DataFrame 的 sum 函数

00:03:34.820 --> 00:03:36.670
但在这里 它是一个 groupby 对象

00:03:36.670 --> 00:03:40.440
所以 我想知道 groupby 对象还有什么其它函数

00:03:40.440 --> 00:03:43.030
如果没有你需要的函数怎么办？

00:03:43.030 --> 00:03:44.520
与 series 和 DataFrame 相同

00:03:44.520 --> 00:03:48.690
groupby 对象有很多方便使用的内置函数

00:03:48.690 --> 00:03:52.520
如果仍找不到你需要的函数 你可以用 apply 函数编写你自己的函数

00:03:52.520 --> 00:03:53.810
在下面的练习中

00:03:53.810 --> 00:03:56.790
我希望你能选择一个变量 对地铁数据进行分组

00:03:56.790 --> 00:04:00.600
比如 一周的每一天、一天的每一小时或是否下雨

00:04:00.600 --> 00:04:04.110
然后找出各变量对应的地铁平均客流量

00:04:04.110 --> 00:04:06.020
生成一个显示结果的图表 

00:04:06.020 --> 00:04:08.260
或者直接将数字结果打出来

