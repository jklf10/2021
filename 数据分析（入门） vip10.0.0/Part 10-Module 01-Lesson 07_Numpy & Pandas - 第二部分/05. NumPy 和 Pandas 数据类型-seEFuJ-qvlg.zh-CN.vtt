WEBVTT
Kind: captions
Language: zh-CN

00:00:00.350 --> 00:00:03.872
在上一节课中 我们看到 NumPy 数组有一个 dtype

00:00:03.872 --> 00:00:05.352
即数组中每一个元素的类型

00:00:05.352 --> 00:00:09.253
比如 这个数组的 dtype 是 int64

00:00:09.253 --> 00:00:11.360
int64 表示64位的整数

00:00:12.985 --> 00:00:16.024
这也适用于二维数组

00:00:16.024 --> 00:00:19.341
数组中的每一个元素都应属于同一类型

00:00:19.341 --> 00:00:23.219
这不便于我们利用 NumPy 二维数组

00:00:23.219 --> 00:00:25.405
来表现 CSV 文件的内容

00:00:25.405 --> 00:00:29.282
例如 如果我试图创建一个 NumPy 数组

00:00:29.282 --> 00:00:31.565
来表示第一节课中的学生的课程注册数据

00:00:31.565 --> 00:00:34.530
我在这里还原了一部分相关数据

00:00:34.530 --> 00:00:37.300
尽管在创建数组时 我输入的整数和布尔值没有加引号

00:00:37.300 --> 00:00:41.650
但每一个元素仍被转换成了一个字符串

00:00:41.650 --> 00:00:46.330
它的 dtype 仍为 s14 即字符串最长为14位

00:00:46.330 --> 00:00:51.170
计算 cancelled 等字符串的平均值 显然没有任何意义

00:00:51.170 --> 00:00:55.300
但我们计算 days_to_cancel 列的平均值仍然有意义

00:00:55.300 --> 00:00:58.910
days_to_cancel 列是第三列 因此 我可以这样获取数据

00:01:00.260 --> 00:01:04.828
但我无法计算这一列的平均值

00:01:04.828 --> 00:01:09.320
NumPy 显示其无法对变化的类型进行缩减

00:01:09.320 --> 00:01:12.230
也就是说 当存在非值的值时

00:01:12.230 --> 00:01:14.070
它便无法计算平均值

00:01:14.070 --> 00:01:18.630
这就是 Pandas DataFrame优于 NumPy 二维数组的地方

00:01:18.630 --> 00:01:21.710
DataFrame也是二维数据结构

00:01:21.710 --> 00:01:23.870
但每一列可为不同类型

00:01:24.870 --> 00:01:29.030
DataFrame的另一个优点是拥有类似 Pandas 的 series 的索引

00:01:29.030 --> 00:01:32.050
每一行都有一个索引值 每一列都有一个名称

00:01:33.350 --> 00:01:36.990
因此 我要利用该数据创建一个 Pandas DataFrame

00:01:36.990 --> 00:01:40.150
为此 我可以输入一个字典

00:01:40.150 --> 00:01:42.710
使列名称映射其值列表

00:01:42.710 --> 00:01:46.450
字典中的关键字之一是 account_key

00:01:46.450 --> 00:01:50.160
列表为 account_key 列的所有值

00:01:50.160 --> 00:01:52.740
同样地 其它列可以此类推

00:01:52.740 --> 00:01:56.390
我们可以看到DataFrame呈现为简明的表格

00:01:56.390 --> 00:01:58.191
列名称位于顶端

00:01:58.191 --> 00:02:00.870
行索引值为从0开始的整数

00:02:00.870 --> 00:02:03.740
创建 Pandas DataFrame的方式还有很多

00:02:03.740 --> 00:02:04.940
我们将随后进行讲解

00:02:06.100 --> 00:02:08.000
现在 如果我取DataFrame的平均值

00:02:08.000 --> 00:02:11.610
它会取每一列值的平均值并忽视其他值

00:02:11.610 --> 00:02:15.690
is_udacity 是一个值列

00:02:15.690 --> 00:02:17.980
它将真和假分别视为1和0

00:02:17.980 --> 00:02:21.680
你会发现 Pandas 并没有计算整个DataFrame的平均值

00:02:21.680 --> 00:02:23.430
而是计算了各列的平均值

00:02:23.430 --> 00:02:26.240
由于每一列可能属于不同类型

00:02:26.240 --> 00:02:28.760
所以 Pandas 这样的做法更合理

00:02:28.760 --> 00:02:32.680
你还可以利用数轴参数来计算各行的平均值

00:02:32.680 --> 00:02:34.240
但由于每一行都包含非值数据

00:02:34.240 --> 00:02:36.760
所以这种做法在这里是不可行的

