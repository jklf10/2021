WEBVTT
Kind: captions
Language: zh-CN

00:00:00.300 --> 00:00:03.690
到目前为止 我们每次都只使用一个 DataFrame

00:00:03.690 --> 00:00:06.510
但在很多情况下 

00:00:06.510 --> 00:00:07.910
我们需要使用多个 DataFrame

00:00:07.910 --> 00:00:10.890
例如 在第一节课中 我们有三个 CSV

00:00:10.890 --> 00:00:12.340
如果你在使用 Pandas

00:00:12.340 --> 00:00:14.950
你就要将它们加载为三个 DataFrame

00:00:14.950 --> 00:00:17.750
例如 如果我想分析

00:00:17.750 --> 00:00:20.370
学生在提交项目后注销的几率

00:00:20.370 --> 00:00:23.560
那我就需要项目提交和注册人数

00:00:23.560 --> 00:00:25.200
这两个表的相关信息

00:00:25.200 --> 00:00:29.050
为了让这个问题简单点 我仅使用了两个表的几个列

00:00:29.050 --> 00:00:32.729
Pandas 有一个名为合并 (merge) 的运算

00:00:32.729 --> 00:00:34.740
它可以将两个表格合并为一个表格

00:00:34.740 --> 00:00:38.300
从而创建一个含有这两个表格所有列的新表格

00:00:38.300 --> 00:00:40.650
注意 这里不存在

00:00:40.650 --> 00:00:42.100
没有相应项目提交的注册数据

00:00:42.100 --> 00:00:45.620
在这个示例中 我只关注没有提交项目的学生

00:00:45.620 --> 00:00:47.430
所以我要忽略这一行

00:00:47.430 --> 00:00:49.640
稍后我会告诉你如何完成这一步

00:00:49.640 --> 00:00:50.520
那么 新表格中的每一行

00:00:50.520 --> 00:00:54.150
都对应提交表中的一行

00:00:54.150 --> 00:00:57.100
而注册表中将根据账户密码

00:00:57.100 --> 00:00:58.540
匹配相应的列

00:00:58.540 --> 00:01:01.270
所以 账户密码 1 的注册时间为 5 月 11 日

00:01:01.270 --> 00:01:06.760
账户密码 2 的注册时间为 5 月 13 日 等等

00:01:06.760 --> 00:01:09.670
注意 如果注册表中某一账户有重复信息

00:01:09.670 --> 00:01:12.260
例如 假设账户密码 2 有两条登陆信息

00:01:12.260 --> 00:01:17.680
那么账户密码 2 提交的所有项目也会被复制

00:01:17.680 --> 00:01:20.110
所以 同一个提交项目会有两行数据

00:01:20.110 --> 00:01:22.310
一行是第一次登陆 一行是第二次登陆

00:01:23.330 --> 00:01:26.560
因此 在进行合并前 最好根据你的案例

00:01:26.560 --> 00:01:30.630
删除注册表中的重复条目

00:01:30.630 --> 00:01:34.667
我为此次合并编写的代码是 submissions.merge

00:01:34.667 --> 00:01:37.159
 (enrolments, on='account_key', how='left')

00:01:37.159 --> 00:01:40.830
on='account_key' 规定如何将不同表格的行

00:01:40.830 --> 00:01:42.130
进行匹配

00:01:42.130 --> 00:01:45.090
在这种情况下 它是按照账户密码来匹配的

00:01:45.090 --> 00:01:47.960
how='left' 决定的是 

00:01:47.960 --> 00:01:51.680
当部分账户密码仅存在于一个表中时的运算 比如这一个

00:01:51.680 --> 00:01:56.210
该参数的可选值包括内、右、左、外

00:01:56.210 --> 00:01:59.330
在这种情况下 how ='inner' 是可用的

00:01:59.330 --> 00:02:03.440
当你使用 inner 时 只有账户密码同时存在于两个表的行

00:02:03.440 --> 00:02:05.643
才能够被保存 所以 这一行会被舍弃

00:02:05.643 --> 00:02:07.037
如果 how='right'

00:02:07.037 --> 00:02:10.205
那么 右侧注册表中的行

00:02:10.205 --> 00:02:13.900
即使在提交表中没有相应条目 也会被保留

00:02:13.900 --> 00:02:17.560
而由于这个账户密码在项目提交表中没有相应数据

00:02:17.560 --> 00:02:20.140
所以 这些列均显示 NaN

00:02:20.140 --> 00:02:22.480
How='left' 的作用正好相反

00:02:22.480 --> 00:02:25.520
即使左侧表中的行在右侧表中没有对应行

00:02:25.520 --> 00:02:27.520
它会被保留

00:02:27.520 --> 00:02:29.390
这里不存在这种情况

00:02:29.390 --> 00:02:31.580
所以 left 和 inner 的作用是一样的

00:02:31.580 --> 00:02:34.960
如果你使用 outer 那么两个表的所有行都会被保留

00:02:34.960 --> 00:02:35.980
需要时 某些行会显示 NaN

00:02:36.980 --> 00:02:40.470
我发现 inner 是最常用到的合并类型

00:02:40.470 --> 00:02:42.040
但最终还是取决于样本的情况

00:02:43.060 --> 00:02:44.750
顺便说一下 如果你使用了 SQL

00:02:44.750 --> 00:02:48.950
你可能会发现 Pandas 的合并类似于 SQL 的连接 (join)

00:02:48.950 --> 00:02:51.920
如果你没有用过 SQL 就不用考虑这个问题了

00:02:51.920 --> 00:02:54.030
纽约数据集的地铁和天气数据

00:02:54.030 --> 00:02:57.950
的数据来源各不相同

00:02:57.950 --> 00:03:01.700
在下一个练习中 我希望你能利用合并函数

00:03:01.700 --> 00:03:04.810
将这两个文件合并为一个 DataFrame

00:03:04.810 --> 00:03:07.620
这会使数据的格式转变为

00:03:07.620 --> 00:03:08.780
你目前在这节课中所用到的格式

