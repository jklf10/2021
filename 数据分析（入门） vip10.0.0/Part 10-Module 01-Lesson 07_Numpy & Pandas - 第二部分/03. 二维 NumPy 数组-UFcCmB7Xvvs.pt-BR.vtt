WEBVTT
Kind: captions
Language: pt-BR

00:00:00.190 --> 00:00:02.500
Na última lição, você trabalhou muito
com dados unidimensionais.

00:00:02.500 --> 00:00:05.689
Nesta lição, você vai
trabalhar com dados bidimensionais,

00:00:05.689 --> 00:00:07.480
que têm linhas e colunas.

00:00:08.790 --> 00:00:11.080
No Python sem bibliotecas,

00:00:11.080 --> 00:00:13.860
você pode representar esses
dados usando uma lista de listas.

00:00:13.860 --> 00:00:17.740
Assim, tenha uma lista para a primeira linha,
outra para a segunda linha etc.

00:00:17.740 --> 00:00:19.880
e
depois coloque cada uma dessas listas em uma lista.

00:00:20.950 --> 00:00:23.740
No NumPy, em vez de criar
um array de arrays,

00:00:23.740 --> 00:00:26.770
você pode criar um único array
bidimensional.

00:00:26.770 --> 00:00:27.300
No Pandas,

00:00:27.300 --> 00:00:30.900
há uma estrutura de dados diferente para
dados bidimensionais chamada DataFrame.

00:00:30.900 --> 00:00:34.250
Como na última lição, prefiro
usar o Pandas, pois ele tem uma funcionalidade

00:00:34.250 --> 00:00:37.610
adicional, mas começarei
com o NumPy que é mais simples.

00:00:38.700 --> 00:00:41.350
Qual é a diferença entre
criar um array bidimensional

00:00:41.350 --> 00:00:44.900
único no NumPy, em vez de criar
um array unidimensional cujos

00:00:44.900 --> 00:00:47.180
elementos também são arrays?

00:00:47.180 --> 00:00:50.300
Uma diferença importante é que
pela forma que o NumPy é implementado,

00:00:50.300 --> 00:00:53.320
a criação de um array bidimensional único
é mais eficiente em termos de memória.

00:00:53.320 --> 00:00:57.330
Se quiser saber mais sobre isso,
siga o link nas Notas do instrutor.

00:00:57.330 --> 00:01:00.950
A sintaxe para acessar os
elementos também é um pouco diferente.

00:01:00.950 --> 00:01:05.360
Digamos que você queira acessar o elemento
na linha um e na coluna três.

00:01:05.360 --> 00:01:09.265
Você faz isso usando
o código a,[1,3] em vez de

00:01:09.265 --> 00:01:14.580
a[1][3] que é o que faria para
um array de arrays.

00:01:14.580 --> 00:01:18.380
Você também pode fazer isso usando a posição
da linha, a posição da coluna ou

00:01:18.380 --> 00:01:21.070
ambas,
em vez de um único número

00:01:21.070 --> 00:01:24.160
usando a notação de dois-pontos
que aprendeu na última lição.

00:01:24.160 --> 00:01:27.280
Outra diferença está nas funções
que você aprendeu na última lição, média,

00:01:27.280 --> 00:01:29.260
desvio padrão etc.

00:01:29.260 --> 00:01:30.900
Com um array bidimensional,

00:01:30.900 --> 00:01:33.720
essas funções vão operar
em todo o array.

00:01:33.720 --> 00:01:37.100
Nesse caso, média calcularia
a média desses valores,

00:01:37.100 --> 00:01:39.620
ignorando as linhas e
colunas onde eles estão.

00:01:39.620 --> 00:01:41.690
Você não pode usar a média
de um array de arrays,

00:01:41.690 --> 00:01:44.860
embora possa usar a média
de cada linha individual.

00:01:44.860 --> 00:01:47.470
Na próxima tela, você terá
uma chance de conhecer isso usando

00:01:47.470 --> 00:01:50.270
um array principal para
representar o número de passageiros do metrô.

00:01:50.270 --> 00:01:54.540
Cada linha terá uma data diferente e
cada coluna terá uma estação diferente.

00:01:54.540 --> 00:01:57.350
Tente o código de exemplo
fornecido para ver o que ele faz.

00:01:57.350 --> 00:02:00.870
Em seguida, grave uma função que primeiro localiza
a estação com o máximo de passageiros

00:02:00.870 --> 00:02:01.430
no primeiro dia.

00:02:02.440 --> 00:02:06.030
Depois, localize a média de passageiros por dia para
essa estação.

00:02:06.030 --> 00:02:09.590
Além disso, retorne a média de passageiros por dia
em todas as estações para comparação.

