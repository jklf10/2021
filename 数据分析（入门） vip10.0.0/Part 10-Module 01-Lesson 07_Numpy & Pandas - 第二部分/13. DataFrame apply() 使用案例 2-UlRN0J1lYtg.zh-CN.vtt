WEBVTT
Kind: captions
Language: zh-CN

00:00:00.500 --> 00:00:01.888
和之前一样

00:00:01.888 --> 00:00:04.387
我先写出在单列上运算的函数

00:00:04.387 --> 00:00:06.790
我把它称为 second_largest_in_column

00:00:06.790 --> 00:00:09.412
想要在一列中找出第二大值

00:00:09.412 --> 00:00:11.420
我们有很多种方法

00:00:11.420 --> 00:00:14.011
一种就是 我把这一列值

00:00:14.011 --> 00:00:15.037
按降序排列

00:00:15.037 --> 00:00:17.280
然后找到该列的第二个值

00:00:17.280 --> 00:00:20.039
我们还没有对 pandasSeries 进行过排序

00:00:20.039 --> 00:00:22.950
所以 我先用 Google 查一下 pandas sort series

00:00:24.180 --> 00:00:27.440
第一个链接是 pandas 中

00:00:27.440 --> 00:00:29.004
sort 函数的文档页面

00:00:29.004 --> 00:00:30.555
这个看起来就是我要找的内容

00:00:30.555 --> 00:00:33.320
但这里有一个注释称 该函数已被弃用 (deprecated)

00:00:33.320 --> 00:00:36.389
而我应该使用 sort_values 函数 且 inplace 等于真值

00:00:36.389 --> 00:00:39.370
以进行原地排序

00:00:39.370 --> 00:00:41.495
我单击底部的这个链接

00:00:41.495 --> 00:00:44.129
查看 sort_values 函数的文档

00:00:44.129 --> 00:00:46.859
我发现 inplace 参数决定

00:00:46.859 --> 00:00:48.764
series 是会进行原地 (inplace) 排序

00:00:48.764 --> 00:00:51.254
还是创建一个新的 series

00:00:51.254 --> 00:00:54.310
我不想更改原来的 series

00:00:54.310 --> 00:00:56.480
因此 我将 inplace 设为假值

00:00:56.480 --> 00:00:59.190
也就是 inplace 的默认值

00:00:59.190 --> 00:01:01.880
我还看到 有一个名为升序 (ascending) 的参数

00:01:01.880 --> 00:01:04.349
它控制 series 是按照升序

00:01:04.349 --> 00:01:06.080
还是降序排列

00:01:06.080 --> 00:01:07.520
我把它设为假值

00:01:07.520 --> 00:01:10.160
这样 series 就会按照降序排列了

00:01:10.160 --> 00:01:13.120
我在这里调用 sort_values 函数并将升序设为假值

00:01:13.120 --> 00:01:16.296
这样就创建了一个排序后的列

00:01:16.296 --> 00:01:19.100
我之前说过 我使用了 inplace 的默认值

00:01:20.130 --> 00:01:22.560
排序后的列是一个 pandasSeries

00:01:22.560 --> 00:01:26.210
我可以用 iloc 来获取第二个值

00:01:26.210 --> 00:01:28.060
第二个值位于位置 1

00:01:29.320 --> 00:01:31.590
现在 我要尝试在 DataFrame 的某一列上调用这一函数

00:01:31.590 --> 00:01:33.150
以检验它是否有效

00:01:34.760 --> 00:01:36.430
它的返回值为 4

00:01:36.430 --> 00:01:38.190
这确实是 A 列的第二大值

00:01:39.280 --> 00:01:42.141
现在 我准备好键入

00:01:42.141 --> 00:01:44.175
可传入整个 DataFrame 的 second_largest 函数

00:01:44.175 --> 00:01:46.008
具体工作已经完成

00:01:46.008 --> 00:01:48.815
我现在只需对 DataFrame apply

00:01:48.815 --> 00:01:50.310
second_largest_in_column 函数

00:01:50.310 --> 00:01:53.019
最后 我要在测试 DataFrame 上调用这个函数

00:01:53.019 --> 00:01:54.850
看起来 它能够正常运算

