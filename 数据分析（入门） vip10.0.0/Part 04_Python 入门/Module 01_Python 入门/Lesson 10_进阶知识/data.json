{
  "data": {
    "lesson": {
      "id": 869731,
      "key": "fb382a34-6de7-4a4b-95ca-08059a5993dd",
      "title": "进阶知识",
      "semantic_type": "Lesson",
      "is_public": true,
      "version": "1.0.0",
      "locale": "zh-cn",
      "summary": "在本课中，我们将介绍迭代器和生成器等一些进阶主题。",
      "lesson_type": "Classroom",
      "display_workspace_project_only": false,
      "resources": {
        "files": [
          {
            "name": "Videos Zip File",
            "uri": "https://zips.udacity-data.com/fb382a34-6de7-4a4b-95ca-08059a5993dd/738079/1544291393618/Advanced+Topics+Videos.zip"
          },
          {
            "name": "Transcripts Zip File",
            "uri": "https://zips.udacity-data.com/fb382a34-6de7-4a4b-95ca-08059a5993dd/738079/1544291391382/Advanced+Topics+Subtitles.zip"
          }
        ],
        "google_plus_link": null,
        "career_resource_center_link": null,
        "coaching_appointments_link": null,
        "office_hours_link": null,
        "aws_provisioning_link": null
      },
      "project": null,
      "lab": null,
      "concepts": [
        {
          "id": 868955,
          "key": "bb7e01c7-1d14-43cf-95da-a8eed788ff7e",
          "title": "进阶主题",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "bb7e01c7-1d14-43cf-95da-a8eed788ff7e",
            "completed_at": "2019-04-03T10:49:14.286Z",
            "last_viewed_at": "2019-04-03T10:49:15.571Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 867241,
              "key": "2834e372-3db3-45ac-ad63-4f07f39d912a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "在本课中，我们将介绍生成器函数和迭代器等进阶主题。",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 534115,
          "key": "50247542-7933-4afe-9130-ff1dff429b03",
          "title": "【选修】迭代器和生成器",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "50247542-7933-4afe-9130-ff1dff429b03",
            "completed_at": "2019-04-03T10:49:18.706Z",
            "last_viewed_at": "2019-04-03T10:49:19.978Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 534023,
              "key": "017906ac-48a8-48c1-88af-32c4698b831d",
              "title": "L4 10 迭代器和生成器 V2",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "tYH8X4Zeh-0",
                "china_cdn_id": "tYH8X4Zeh-0.mp4"
              }
            },
            {
              "id": 534028,
              "key": "3487d6fb-ec0d-4fdf-ab14-66b78479dc20",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 迭代器和生成器\n__迭代器__是每次可以返回一个对象元素的对象，例如返回一个列表。我们到目前为止使用的很多内置函数（例如 enumerate）都会返回一个迭代器。\n\n__迭代器__是一种表示数据流的对象。这与列表不同，列表是可迭代对象，但不是迭代器，因为它不是数据流。\n\n__生成器__是使用函数创建迭代器的简单方式。也可以使用__类__定义迭代器，更多详情请参阅[此处](https://docs.python.org/3/tutorial/classes.html#iterators)。\n\n下面是一个叫做 `my_range` 的生成器函数，它会生成一个从 0 到 (x - 1) 的数字流。\n\n```python\ndef my_range(x):\n    i = 0\n    while i < x:\n        yield i\n        i += 1\n```\n注意，该函数使用了 yield 而不是关键字 return。这样使函数能够一次返回一个值，并且每次被调用时都从停下的位置继续。关键字 yield 是将生成器与普通函数区分开来的依据。\n\n注意，因为这段代码会返回一个迭代器，因此我们可以将其转换为列表或用 for 循环遍历它，以查看其内容。例如，下面的代码：\n```python\nfor x in my_range(5):\n    print(x)\n```\n输出：\n```txt\n0\n1\n2\n3\n4\n```",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 534120,
          "key": "8f8f635f-3a64-4430-9f5a-1b9cae806e6d",
          "title": "【选修】练习：迭代器和生成器",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "8f8f635f-3a64-4430-9f5a-1b9cae806e6d",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 534029,
              "key": "951cd3c5-a374-41fb-822a-65d7b74e2868",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 练习：实现 `my_enumerate`\n请自己写一个效果和内置函数 `enumerate` 一样的生成器函数。\n\n如下所示地调用该函数：\n```python\nlessons = [\"Why Python Programming\", \"Data Types and Operators\", \"Control Flow\", \"Functions\", \"Scripting\"]\n\nfor i, lesson in my_enumerate(lessons, 1):\n    print(\"Lesson {}: {}\".format(i, lesson))\n```\n应该会输出：\n```txt\nLesson 1: Why Python Programming\nLesson 2: Data Types and Operators\nLesson 3: Control Flow\nLesson 4: Functions\nLesson 5: Scripting\n```",
              "instructor_notes": ""
            },
            {
              "id": 534030,
              "key": "cf6d568a-79f0-44dc-b136-8b05b7484805",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "cf6d568a-79f0-44dc-b136-8b05b7484805",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "5163475710640128",
                "initial_code_files": [
                  {
                    "text": "lessons = [\"Why Python Programming\", \"Data Types and Operators\", \"Control Flow\", \"Functions\", \"Scripting\"]\n\ndef my_enumerate(iterable, start=0):\n    # Implement your generator function here\n\n\nfor i, lesson in my_enumerate(lessons, 1):\n    print(\"Lesson {}: {}\".format(i, lesson))",
                    "name": "my_enumerate.py"
                  }
                ]
              },
              "answer": null
            },
            {
              "id": 534031,
              "key": "82478a92-8a6e-49a2-9c7b-141244ba910f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 为何要使用生成器？\n你可能会疑问，为何要使用生成器，而不使用列表。下面这段摘自 [stack overflow 页面](https://softwareengineering.stackexchange.com/questions/290231/when-should-i-use-a-generator-and-when-a-list-in-python/290235) 的内容回答了这个问题：\n\n>生成器是构建迭代器的 “懒惰” 方式。当内存不够存储完整实现的列表时，或者计算每个列表元素的代价很高，你希望尽量推迟计算时，就可以使用生成器。但是这些元素只能遍历一次。\n\n另一种详细的解释如下（详细说明参见 [该 stack overflow 页面](https://softwareengineering.stackexchange.com/questions/273551/should-i-prefer-python-generators-to-lists)。）\n\n> 由于使用生成器是一次处理一个数据，在内存和存储的需求上会比使用 list 方式直接全部生成再存储节省很多资源。\n\n> 由此区别，在处理大量数据时，经常使用生成器初步处理数据后，再进行长期存储，而不是使用 list。因为无论使用生成器还是 list，都是使用过就要丢弃的临时数据。既然功能和结果一样，那就不如用生成器。\n\n> 但是生成器也有自己的局限，它产生的数据不能回溯，不像 list 可以任意选择。\n",
              "instructor_notes": ""
            },
            {
              "id": 534032,
              "key": "3180c2d9-1643-48bf-903b-5b3b26ae3c67",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 练习：Chunker\n如果可迭代对象太大，无法完整地存储在内存中（例如处理大型文件时），每次能够使用一部分很有用。\n\n实现一个生成器函数 `chunker`，接受一个可迭代对象并每次生成指定大小的部分数据。\n\n如下所示地调用该函数：\n```python\nfor chunk in chunker(range(25), 4):\n    print(list(chunk))\n```\n应该会输出：\n```txt\n[0, 1, 2, 3]\n[4, 5, 6, 7]\n[8, 9, 10, 11]\n[12, 13, 14, 15]\n[16, 17, 18, 19]\n[20, 21, 22, 23]\n[24]\n```",
              "instructor_notes": ""
            },
            {
              "id": 534038,
              "key": "fcf5292d-f95b-40fa-a76e-b5beff5dbb7d",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "fcf5292d-f95b-40fa-a76e-b5beff5dbb7d",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "6466613495332864",
                "initial_code_files": [
                  {
                    "text": "def chunker(iterable, size):\n    # Implement function here\n\n\nfor chunk in chunker(range(25), 4):\n    print(list(chunk))",
                    "name": "chunker.py"
                  }
                ]
              },
              "answer": null
            }
          ]
        },
        {
          "id": 534119,
          "key": "7da0a9fa-5c9b-4e81-a043-0fabd59ba8f0",
          "title": "【选修】解决方案：迭代器和生成器",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "7da0a9fa-5c9b-4e81-a043-0fabd59ba8f0",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 534039,
              "key": "928aa1fb-97d8-4e61-8b0f-e47e00fd11a1",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 练习解决方案：实现 `my_enumerate`\n```python\nlessons = [\"Why Python Programming\", \"Data Types and Operators\", \"Control Flow\", \"Functions\", \"Scripting\"]\n\ndef my_enumerate(iterable, start=0):\n    count = start\n    for element in iterable:\n        yield count, element\n        count += 1\n\nfor i, lesson in my_enumerate(lessons, 1):\n    print(\"Lesson {}: {}\".format(i, lesson))\n```\n### 输出：\n```txt\nLesson 1: Why Python Programming\nLesson 2: Data Types and Operators\nLesson 3: Control Flow\nLesson 4: Functions\nLesson 5: Scripting\n```",
              "instructor_notes": ""
            },
            {
              "id": 534040,
              "key": "d3a112f8-ec87-413e-8a29-216f93f826a5",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# 练习解决方案：Chunker\n以下是一种实现方式。你可以在此 [Stack Overflow 页面](https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks)上找到该实现。\n```python\ndef chunker(iterable, size):\n    \"\"\"Yield successive chunks from iterable of length size.\"\"\"\n    for i in range(0, len(iterable), size):\n        yield iterable[i:i + size]\n\nfor chunk in chunker(range(25), 4):\n    print(list(chunk))\n```\n### 输出：\n```txt\n[0, 1, 2, 3]\n[4, 5, 6, 7]\n[8, 9, 10, 11]\n[12, 13, 14, 15]\n[16, 17, 18, 19]\n[20, 21, 22, 23]\n[24]\n```",
              "instructor_notes": ""
            }
          ]
        }
      ]
    }
  }
}