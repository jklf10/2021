WEBVTT
Kind: captions
Language: ar

00:00:00.262 --> 00:00:03.308
حتى الآن في هذا الدرس، كنت تجري الحسابات
على المتسلسلات

00:00:03.308 --> 00:00:05.242
باستخدام دوال
.مدمجة

00:00:05.242 --> 00:00:08.946
على سبيل المثال، دوال المتوسط
.وعمليات التحويل إلى رسومات المتجهات

00:00:08.946 --> 00:00:12.310
على سبيل المثال، plus للإشارة إلى
.الإضافة الموجهة

00:00:12.310 --> 00:00:14.590
ولكن ما الذي ستفعله
عندما ترغب في إجراء بعض الحسابات

00:00:14.590 --> 00:00:17.100
غير المدمجة
في pandas والتي

00:00:17.100 --> 00:00:19.660
لا يمكن إجراؤها باستخدام
العمليات الموجهة البسيطة؟

00:00:20.910 --> 00:00:22.240
،كما رأيتَ من قبل

00:00:22.240 --> 00:00:24.780
قد يتمثل أحد الخيارات في التعامل مع
المتسلسلات كقائمة باستخدام

00:00:24.780 --> 00:00:25.670
أربعة تكرارات

00:00:25.670 --> 00:00:27.690
أو الوصول إلى العناصر
.الفردية لهذه المتسلسلات

00:00:28.880 --> 00:00:30.600
وهناك خيار آخر على الرغم
من ذلك وهو

00:00:30.600 --> 00:00:33.520
أن pandas تشتمل على دالة تُسمى
apply() والتي يمكنك استخدامها

00:00:33.520 --> 00:00:35.949
لإجراء الحسابات التي
.لا يتم دمجها في Pandas

00:00:37.125 --> 00:00:38.290
وتستخدم الدالة Apply() متسلسلة ودالة a

00:00:38.290 --> 00:00:41.590
وتنشئ
متسلسلة جديدة بتطبيق

00:00:41.590 --> 00:00:44.030
الدالة على كل عنصر
.من المتسلسلة الأصلية

00:00:45.040 --> 00:00:48.300
ولهذا، على سبيل المثال، افترض
أن الدالة كانت add three، وهو ما يحتاج لاستخدام

00:00:48.300 --> 00:00:50.240
رقم وإضافة
.ثلاثة إليه

00:00:51.390 --> 00:00:54.247
وقد يؤدي تطبيق هذه الدالة على
المتسلسلة باليسار إلى إنشاء

00:00:54.247 --> 00:00:55.481
.المتسلسلة الموجودة على اليمين

00:00:55.481 --> 00:00:58.774
أولاً، قد يتم تطبيق الدالة add three
على العنصر الأول

00:00:58.774 --> 00:01:00.426
.من المتسلسلة مما يؤدي إلى ناتج يساوي أربعة

00:01:00.426 --> 00:01:03.139
وبعد ذلك، قد يتم تطبيق الدالة add three
على العنصر الثاني

00:01:03.139 --> 00:01:05.269
.من المتسلسلة مما يؤدي إلى ناتج يساوي خمسة

00:01:05.269 --> 00:01:08.460
وبعد ذلك، قد يتم تطبيق الدالة add three
على العنصر الثالث

00:01:08.460 --> 00:01:08.990
.من المتسلسلة مما يؤدي إلى ناتج يساوي ستة وهكذا

00:01:10.610 --> 00:01:13.700
إذا كنت على دراية
()بدالة Python، فإن الدالة map apply

00:01:13.700 --> 00:01:17.190
مطابقة تمامًا لها، ولكنها
.تُطبق على المتسلسلات بدلاً من القوائم

00:01:17.190 --> 00:01:19.740
وإذا لم تكن قد سمعت من قبل عن الدالة map
.فهذا جيد أيضًا

00:01:19.740 --> 00:01:21.206
والآن في هذا المثال الخاص
بإضافة ثلاثة

00:01:21.206 --> 00:01:23.392
قد يكون من الأفضل لو استُخدمت الإضافة
.الموجهة

00:01:23.392 --> 00:01:25.870
،وإذا كانت هذه المتسلسلات سُميت s

00:01:25.870 --> 00:01:30.838
لكنت أنت أنشأتَ متسلسلة جديدة
.باستخدام التعليمة البرمجية s+3

00:01:30.838 --> 00:01:35.586
وقد يكون هذا مطابقًا لحالة
.(s.apply(add 3

00:01:35.586 --> 00:01:38.998
ومع ذلك، قد تكون الدالة apply() مفيدة للغاية
في الحالات التي لا تشتمل على

00:01:38.998 --> 00:01:41.699
عملية مدمجة
.تنفذ ما ترغب به

00:01:42.840 --> 00:01:45.950
على سبيل المثال، افترض أن لديك
متسلسلة من الولايات فيها تُمثل بعض الولايات

00:01:45.950 --> 00:01:48.130
باسمها
الكامل

00:01:48.130 --> 00:01:49.470
.وتُمثل أخرى باختصار

00:01:50.710 --> 00:01:53.650
أرغب بتنقيح البيانات باستبدال
كل ولاية ممثلة باسم كامل

00:01:53.650 --> 00:01:54.600
.بالاختصار الخاص بها

00:01:55.680 --> 00:01:56.316
والآن، فلنقل أنني

00:01:56.316 --> 00:01:58.270
كتبت بالفعل
دالة تنفذ هذه المهمة مع ولاية

00:01:58.270 --> 00:01:58.914
.واحدة

00:01:58.914 --> 00:02:01.202
ينبغي أن تبدو التعليمة البرمجية
.قريبة من هذا الشكل

00:02:01.202 --> 00:02:04.371
أولاً، أتحقق ما إذا كانت القيمة
.هي اختصار بالفعل

00:02:04.371 --> 00:02:06.125
وفي هذه الحالة
.أُعيدها إلى الدالة unchanged

00:02:06.125 --> 00:02:08.366
وبعد ذلك أتحقق مما إذا كانت الولاية هي
.ألاباما

00:02:08.366 --> 00:02:11.267
وفي هذه الحالة، سأعيد
اختصار ألاباما

00:02:11.267 --> 00:02:12.490
.وهكذا، ستحصل على البيانات

00:02:13.530 --> 00:02:15.330
والآن أستطيع إنشاء
قائمة فارغة

00:02:15.330 --> 00:02:18.300
ثم تكرار المتسلسلات
ثم استدعاء الدالة my clean_state

00:02:18.300 --> 00:02:20.680
بكل قيمة
في المتسلسلة

00:02:20.680 --> 00:02:23.020
وإلحاق كل قيمة
.جديدة بالقائمة

00:02:23.020 --> 00:02:25.898
ولكن من المحتمل أني أردت بالفعل أن تكون البيانات
المنقحة متسلسلة panda

00:02:25.898 --> 00:02:27.429
بدلاً من قائمة، ولهذا

00:02:27.429 --> 00:02:30.443
قد أحول هذه القائمة إلى متسلسلة
.في نهاية التكرار

00:02:30.443 --> 00:02:33.705
وبدلاً من ذلك، أستطيع
.()استخدام الدالة apply

00:02:33.705 --> 00:02:36.357
أولاً، أكتب اسم المتسلسلة الأصلية
وهي

00:02:36.357 --> 00:02:39.223
states، ثم أقوم باستدعاء
.الدالة apply

00:02:39.223 --> 00:02:41.551
()وكوسيطة للدالة apply
أقدم الدالة

00:02:41.551 --> 00:02:44.236
clean_state
التي كتبتها لتنقيح

00:02:44.236 --> 00:02:45.022
.اسم كل ولاية

00:02:45.022 --> 00:02:47.383
لاحظ أنني لا
أضع أقواسًا بعد

00:02:47.383 --> 00:02:51.280
الدالة clean_state function
.لأنني لا أقوم باستدعاء الدالة هنا

00:02:51.280 --> 00:02:54.867
أنا أقدم الدالة بأكملها
.()كإدخال للدالة apply

00:02:54.867 --> 00:02:57.829
()والميزة الأساسية لاستخدام apply
مقارنة باستخدام تكرار هي

00:02:57.829 --> 00:02:59.650
أن هذه الدالة تستخدم تعليمتك البرمجية
.بدقة أكبر بكثير

00:02:59.650 --> 00:03:01.566
كما أنها قد تكون
.أسرع قليلاً

00:03:01.566 --> 00:03:04.041
ولكن في هذه الحالة، سيُقضى
مجمل الوقت على الأرجح

00:03:04.041 --> 00:03:06.024
في الدالة
.clean_state function

00:03:06.024 --> 00:03:08.603
ولهذا، قد لا يختلف الأمر كثيرًا
بالنسبة لمنظور السرعة

00:03:08.603 --> 00:03:11.190
ما إذا كنت سأستخدم
.()تكرارًا حلقيًا أو الدالة apply

00:03:11.190 --> 00:03:12.560
.والآن حان دورك

00:03:12.560 --> 00:03:15.772
اكتب تعليمة برمجية ستستخدم
متسلسلة في شكل

00:03:15.772 --> 00:03:17.670
الاسم الأول والاسم الأخير

00:03:17.670 --> 00:03:20.820
ثم ضعها في الشكل
.الاسم الأخير، الاسم الأول

00:03:21.820 --> 00:03:24.950
قد تفيدك دالة split&lrm; من Python
وإليك رابط

00:03:24.950 --> 00:03:27.210
للوثائق
.مدرج في ملاحظات المدرب

