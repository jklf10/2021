WEBVTT
Kind: captions
Language: zh-CN

00:00:00.262 --> 00:00:03.308
在这节课中 到目前为止

00:00:03.308 --> 00:00:05.242
你始终在 Series 上使用内置函数进行计算

00:00:05.242 --> 00:00:08.946
例如 平均值函数和向量运算

00:00:08.946 --> 00:00:12.310
比如 代表向量加法的加号

00:00:12.310 --> 00:00:14.590
但如果你要进行的计算

00:00:14.590 --> 00:00:17.100
在 Pandas 中没有内置函数

00:00:17.100 --> 00:00:19.660
也无法通过简单的向量运算进行 那怎么办？

00:00:20.910 --> 00:00:22.240
与之前一样

00:00:22.240 --> 00:00:24.780
可以将 Series 视为列表

00:00:24.780 --> 00:00:25.670
利用 for 循环

00:00:25.670 --> 00:00:27.690
或者 获取 Series 的单个元素

00:00:28.880 --> 00:00:30.600
还有另外一种方法

00:00:30.600 --> 00:00:33.520
Pandas 有一个名为 apply 的函数

00:00:33.520 --> 00:00:35.949
你可以用它进行 Pandas 中没有内置的计算

00:00:37.125 --> 00:00:38.290
apply 函数会载入 Series 和函数

00:00:38.290 --> 00:00:41.590
然后 通过对原 Series 的每个元素调用 (apply) 这个函数

00:00:41.590 --> 00:00:44.030
创建一个新的 Series

00:00:45.040 --> 00:00:48.300
比如 假设把函数与 3 相加 

00:00:48.300 --> 00:00:50.240
也就是把数字与 3 相加

00:00:51.390 --> 00:00:54.247
对左侧 Series 调用该函数

00:00:54.247 --> 00:00:55.481
就会得到右侧的 Series

00:00:55.481 --> 00:00:58.774
首先 Series 的第一个元素与 3 相加

00:00:58.774 --> 00:01:00.426
会得到 4

00:01:00.426 --> 00:01:03.139
然后 再把 Series 的第二个元素与 3 

00:01:03.139 --> 00:01:05.269
相加得到 5

00:01:05.269 --> 00:01:08.460
然后 再把 Series 的第三个元素与 3 相加

00:01:08.460 --> 00:01:08.990
得到 6 以此类推

00:01:10.610 --> 00:01:13.700
如果你熟悉 Python 的 map apply 函数

00:01:13.700 --> 00:01:17.190
两者其实是一样的 只不过这个在 Series 而不是列表上运行 

00:01:17.190 --> 00:01:19.740
如果你没有听说过 map apply 函数 也没关系

00:01:19.740 --> 00:01:21.206
在这个加 3 的例子中

00:01:21.206 --> 00:01:23.392
使用向量加法会更好

00:01:23.392 --> 00:01:25.870
如果这个 Series 叫做 s

00:01:25.870 --> 00:01:30.838
那么你就可以用代码 s + 3 创建新的 Series

00:01:30.838 --> 00:01:35.586
这与 s.apply(add3) 是一样的

00:01:35.586 --> 00:01:38.998
但在没有你需要的内置运算时

00:01:38.998 --> 00:01:41.699
apply 函数就很有用了

00:01:42.840 --> 00:01:45.950
例如 假如你有一个州的 Series

00:01:45.950 --> 00:01:48.130
其中 部分州是全称

00:01:48.130 --> 00:01:49.470
其它的是简称

00:01:50.710 --> 00:01:53.650
我想要清理数据

00:01:53.650 --> 00:01:54.600
用各州的简称代替其全称

00:01:55.680 --> 00:01:56.316
假设

00:01:56.316 --> 00:01:58.270
我已经编写了

00:01:58.270 --> 00:01:58.914
清理单个数据的函数

00:01:58.914 --> 00:02:01.202
这个代码大概就是这样的

00:02:01.202 --> 00:02:04.371
首先 我检查这个值是否是简称

00:02:04.371 --> 00:02:06.125
如果是 我不做改动 直接返回

00:02:06.125 --> 00:02:08.366
接下来 我检查这个州是否是阿拉巴马

00:02:08.366 --> 00:02:11.267
如果是 我就返回阿拉巴马的简称

00:02:11.267 --> 00:02:12.490
以此类推

00:02:13.530 --> 00:02:15.330
我可以创建一个空列表

00:02:15.330 --> 00:02:18.300
遍历这个 Series

00:02:18.300 --> 00:02:20.680
然后 对 Series 中的每个元素调用我的 clean_state 函数

00:02:20.680 --> 00:02:23.020
再将每个新值添加到列表中

00:02:23.020 --> 00:02:25.898
但我希望清理后的数据是 Panda Series

00:02:25.898 --> 00:02:27.429
而不是列表

00:02:27.429 --> 00:02:30.443
所以 我可以在循环末尾将列表转换为 Series

00:02:30.443 --> 00:02:33.705
我也可以利用 apply 函数

00:02:33.705 --> 00:02:36.357
首先 我写出原 Series 的名称

00:02:36.357 --> 00:02:39.223
也就是州名称 然后 我调用 apply 函数

00:02:39.223 --> 00:02:41.551
并把我用来清理州数据的

00:02:41.551 --> 00:02:44.236
clean_state 函数

00:02:44.236 --> 00:02:45.022
作为 apply 函数的参数

00:02:45.022 --> 00:02:47.383
注意 我并没有在 clean_state 函数后面加小括号

00:02:47.383 --> 00:02:51.280
在这里 我不是调用这个函数

00:02:51.280 --> 00:02:54.867
我是将整个函数作为 apply 函数的参数

00:02:54.867 --> 00:02:57.829
与循环相比 使用 apply 函数的优点在于

00:02:57.829 --> 00:02:59.650
它能使你的代码更简洁

00:02:59.650 --> 00:03:01.566
它的运算速度也会快一些

00:03:01.566 --> 00:03:04.041
但在这里 大部分时间可能会

00:03:04.041 --> 00:03:06.024
花在 clean_state 函数内

00:03:06.024 --> 00:03:08.603
所以 就速度而言

00:03:08.603 --> 00:03:11.190
使用 loop (循环) 或 apply 函数可能没什么区别

00:03:11.190 --> 00:03:12.560
现在轮到你来做了

00:03:12.560 --> 00:03:15.772
你需要编写一个函数

00:03:15.772 --> 00:03:17.670
使其载入格式为名和姓的名字 Series

00:03:17.670 --> 00:03:20.820
然后 将其转换为姓和名的格式

00:03:21.820 --> 00:03:24.950
Python 的 split 函数可能比较有用

00:03:24.950 --> 00:03:27.210
讲师注释中有相关文件的链接

