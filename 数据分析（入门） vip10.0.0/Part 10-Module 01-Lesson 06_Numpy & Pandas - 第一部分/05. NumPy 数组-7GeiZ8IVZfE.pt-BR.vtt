WEBVTT
Kind: captions
Language: pt-BR

00:00:00.170 --> 00:00:02.960
Tanto o Pandas quanto
o NumPy têm estruturas de dados especiais,

00:00:02.960 --> 00:00:05.180
criadas para representar dados unidimensionais.

00:00:05.180 --> 00:00:08.269
A propósito, NumPy significa
Numerical Python.

00:00:08.269 --> 00:00:10.914
Em Pandas, essa estrutura de dados
é chamada de série e,

00:00:10.914 --> 00:00:13.050
em NumPy, de array.

00:00:13.050 --> 00:00:15.355
Pandas e
NumPy também têm estruturas para

00:00:15.355 --> 00:00:18.730
dados bidimensionais, sobre as quais você
aprenderá na próxima lição.

00:00:18.730 --> 00:00:20.730
Tipicamente, eu prefiro usar a
série do Pandas,

00:00:20.730 --> 00:00:23.200
pois ela tem mais
recursos que os arrays NumPy.

00:00:23.200 --> 00:00:26.360
No entanto, os arrays NumPy são mais simples. Portanto,
falarei sobre eles primeiro.

00:00:26.360 --> 00:00:29.110
As séries Pandas são criadas em
cima de arrays NumPy, portanto

00:00:29.110 --> 00:00:33.390
será importante entender os arrays NumPy
ao avançar para o uso de séries.

00:00:33.390 --> 00:00:36.720
Um array NumPy
é similar a uma lista Python de muitas formas.

00:00:36.720 --> 00:00:39.660
Ela contém uma sequência de elementos que
podem ser qualquer coisa.

00:00:39.660 --> 00:00:42.192
Suponha que você tenha um array NumPy
de CEPs dos EUA.

00:00:42.192 --> 00:00:47.800
Você tem Alabama, Alasca, Arizona,
Arkansas, Califórnia e assim por diante.

00:00:47.800 --> 00:00:51.460
Coloquei aspas nos
estados pois eles são strings.

00:00:51.460 --> 00:00:54.290
Como nas listas, os elementos de
um array NumPy ficam em ordem e

00:00:54.290 --> 00:00:56.910
você pode acessá-los
por suas posições.

00:00:56.910 --> 00:00:59.660
Nesse array NumPy,
Alasca está na posição 0,

00:00:59.660 --> 00:01:01.470
Arkansas na posição 1 e assim por diante.

00:01:03.280 --> 00:01:05.530
Portanto, se você tem um array NumPy chamado de a,

00:01:05.530 --> 00:01:11.210
então a[0] retornaria a string AL para
Alasca.

00:01:11.210 --> 00:01:15.160
Também como nas listas, você pode acessar uma gama
de elementos de um array NumPy usando

00:01:15.160 --> 00:01:17.040
algo que chamamos de divisão.

00:01:17.040 --> 00:01:18.951
Novamente, a sintaxe é igual para
listas.

00:01:18.951 --> 00:01:26.610
Portanto, a[1:3] retornaria um array NumPy
contendo Alasca e Arizona.

00:01:26.610 --> 00:01:29.740
Observe que, como nas listas, o limite
superior não é inclusivo; portanto, tenho

00:01:29.740 --> 00:01:34.820
o elemento na posição 1 e na posição
2, mas não o elemento na posição 3.

00:01:34.820 --> 00:01:36.450
E, por último, você pode usar

00:01:36.450 --> 00:01:40.330
loops for com arrays NumPy usando um código como
"for x in a":.

00:01:40.330 --> 00:01:44.190
Portanto, quais são as diferenças entre
um array NumPy e uma lista Python?

00:01:44.190 --> 00:01:47.630
Primeiramente, os arrays NumPy são projetados para que
cada elemento tenha o mesmo tipo de dados.

00:01:48.710 --> 00:01:52.340
Logo, todos os elementos serão
uma string, todos os elementos serão inteiros,

00:01:52.340 --> 00:01:55.280
serão boolianos ou
outro.

00:01:55.280 --> 00:01:57.700
Você pode criar uma lista Python
que contém algumas strings,

00:01:57.700 --> 00:02:01.820
alguns inteiros, outros boolianos e
assim por diante, todos misturados.

00:02:01.820 --> 00:02:03.710
Você também pode fazer isso em NumPy, mas

00:02:03.710 --> 00:02:06.400
ele foi projetado para que
cada array tenha um único tipo de dados.

00:02:07.660 --> 00:02:10.509
Em segundo lugar, o NumPy inclui várias
funções de conveniência.

00:02:10.509 --> 00:02:14.050
Por exemplo, as funções para tirar
a média para o desvio padrão.

00:02:14.050 --> 00:02:16.910
Você viu na última lição que
também pode usar essas funções em

00:02:16.910 --> 00:02:18.130
listas Python.

00:02:18.130 --> 00:02:22.080
No entanto, se seus dados estiverem em um array NumPy,
essas funções serão mais rápidas.

00:02:22.080 --> 00:02:25.214
Esse é um local onde
o tipo de elemento é importante,

00:02:25.214 --> 00:02:29.098
uma vez que faz sentido tirar a
média do array se todos os elementos

00:02:29.098 --> 00:02:29.991
forem numéricos.

00:02:29.991 --> 00:02:33.405
Outra diferença é que os arrays NumPy
podem ser multidimensionais.

00:02:33.405 --> 00:02:35.255
Você aprenderá mais sobre isso
na próxima lição, mas

00:02:35.255 --> 00:02:37.795
é similar a fazer
uma lista de listas em Python.

00:02:38.855 --> 00:02:41.725
Na próxima tela, você poderá
brincar um pouco com código NumPy

00:02:41.725 --> 00:02:43.455
e ver o que ele faz.

00:02:43.455 --> 00:02:46.295
Recomendo que você leia todas as seções
do código e preveja o que será

00:02:46.295 --> 00:02:51.670
impresso. Depois, mude false para true e
use o Test Run para ver se estava certo.

00:02:51.670 --> 00:02:54.970
Se você não tiver certeza do que será
impresso, use o Test Run para descobrir.

00:02:54.970 --> 00:02:58.720
Se estiver curioso, você também poderá adicionar seu próprio código e
experimentar outras coisas.

00:02:58.720 --> 00:03:00.480
No final do código,
há uma função para

00:03:00.480 --> 00:03:03.800
você escrever chamada max_employment
e verificar sua compreensão.

00:03:03.800 --> 00:03:05.720
Ela leva esses argumentos para arrays NumPy.

00:03:05.720 --> 00:03:07.540
O primeiro contém nomes de países e

00:03:07.540 --> 00:03:10.490
o segundo contém
dados de taxa de emprego para cada país.

00:03:10.490 --> 00:03:13.770
Os nomes dos países estão na mesma
ordem dos dados de taxa de emprego.

00:03:13.770 --> 00:03:17.180
A função deve retornar o nome do
país com a maior taxa de emprego,

00:03:17.180 --> 00:03:21.050
e o valor máximo de taxa de emprego
correspondente nos dados específicos.

00:03:21.050 --> 00:03:24.900
Ao clicar em Test Run, além de
ver o resultado de qualquer código escrito,

00:03:24.900 --> 00:03:27.630
você também verá o resultado da execução
da sua função no conjunto de dados completo

00:03:27.630 --> 00:03:30.000
de taxa de emprego por alguns anos diferentes.

00:03:30.000 --> 00:03:33.320
Se você clicar em Submit, o graduador
verificará se a função está correta.

00:03:33.320 --> 00:03:36.000
Se você quiser testar sua função em
algo menor do que o conjunto completo

00:03:36.000 --> 00:03:39.640
de dados, recomendo testar um dos
arrays fornecidos no topo dessa

00:03:39.640 --> 00:03:40.680
sessão de código.

00:03:40.680 --> 00:03:43.725
Essa contém os primeiros 20
países no conjunto de dados, e

00:03:43.725 --> 00:03:47.591
essa contém os dados de taxa de emprego para
esses países no ano de 2007.

00:03:47.591 --> 00:03:50.222
Como esses arrays têm os nomes
countries e employment,

00:03:50.222 --> 00:03:53.288
você pode testar sua função
neles usando a print line,

00:03:53.288 --> 00:03:55.617
max_employment (countries, employment).

