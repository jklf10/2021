{
  "data": {
    "lesson": {
      "id": 869741,
      "key": "ab874262-fbe1-46c7-965c-155c74af10d5",
      "title": "同步",
      "semantic_type": "Lesson",
      "is_public": true,
      "version": "1.0.0",
      "locale": "zh-cn",
      "summary": "",
      "lesson_type": "Classroom",
      "display_workspace_project_only": false,
      "resources": {
        "files": [
          {
            "name": "Videos Zip File",
            "uri": "https://zips.udacity-data.com/ab874262-fbe1-46c7-965c-155c74af10d5/738091/1544291072941/Staying+In+Sync+With+A+Remote+Repository+Videos.zip"
          },
          {
            "name": "Transcripts Zip File",
            "uri": "https://zips.udacity-data.com/ab874262-fbe1-46c7-965c-155c74af10d5/738091/1544291069494/Staying+In+Sync+With+A+Remote+Repository+Subtitles.zip"
          }
        ],
        "google_plus_link": null,
        "career_resource_center_link": null,
        "coaching_appointments_link": null,
        "office_hours_link": null,
        "aws_provisioning_link": null
      },
      "project": null,
      "lab": null,
      "concepts": [
        {
          "id": 339323,
          "key": "e7123304-aa7e-477a-8586-47acf84d3407",
          "title": "简介",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "e7123304-aa7e-477a-8586-47acf84d3407",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 339259,
              "key": "9f2b9a8a-fdee-4b69-a4e2-360657ab5fda",
              "title": "简介",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "j5RmK0UHOTY",
                "china_cdn_id": "j5RmK0UHOTY.mp4"
              }
            }
          ]
        },
        {
          "id": 339324,
          "key": "9c0c0dd5-225e-44a4-9257-a584a7829207",
          "title": "创建 Pull Request",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "9c0c0dd5-225e-44a4-9257-a584a7829207",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 339261,
              "key": "7698e027-2da0-4c51-b09d-e0ae1396337f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "**Pull Request（拉取请求）**是向**初始**或**源仓库的**维护者发出的请求，以让其将你在他们项目的 fork 上所做的更改应用在他们的项目中。你请求他们**拉取**你做的更改。\n\n我们先对后面的内容进行简要概述，然后再深入学习。",
              "instructor_notes": ""
            },
            {
              "id": 339263,
              "key": "44e122e8-b8c8-41f3-9113-b628fba6d208",
              "title": "L3 - Pull Request 理论",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "twLr9ndsf90",
                "china_cdn_id": "twLr9ndsf90.mp4"
              }
            },
            {
              "id": 339262,
              "key": "8b162ee4-d3f6-447b-9d58-114045ba676d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "接下来我们演练发出 Pull Request 的步骤！如果你一直在跟着我操作，那么现在应该已经将 Lam 的[旅行计划仓库](https://github.com/udacity/course-collaboration-travel-plans) fork 到了自己的帐户，并对 fork 的版本做了一两个额外 commit。\n\n 在上一课中，我创建了一个名为 `include-richards-destinations` 的特性分支，向其中添加了一些 commit，并将该分支推送到了 GitHub。记住，当你创建一个 Pull Request 时，你要将所有更改放在一个专用于这些更改的分支上，还记得我们如何称呼这种类型的分支吗？...特性分支！",
              "instructor_notes": ""
            },
            {
              "id": 339260,
              "key": "0cb6d0f1-458f-4995-bc17-d79a83f9d201",
              "title": "",
              "semantic_type": "TaskListAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "0cb6d0f1-458f-4995-bc17-d79a83f9d201",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "tasks": [
                "我 **fork** 了 Lam 的[项目](https://github.com/udacity/course-collaboration-travel-plans)",
                "我创建了一个特性分支，并赋予了它一个描述性名称",
                "我在我的分支上至少做了一个 commit",
                "我将我的更改推送至**我的** fork"
              ],
              "positive_feedback": "棒极了，让我们继续！",
              "video_feedback": null,
              "description": "我们要创建 Pull Request 了（多么令人激动呀！），先确保我们具有相同的设置。请回答以下问题："
            },
            {
              "id": 339264,
              "key": "1a758402-7a7a-4a8b-b026-c80c20f0af8b",
              "title": "L3 - Pull Request 练习",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "d3AGtKmHxUk",
                "china_cdn_id": "d3AGtKmHxUk.mp4"
              }
            },
            {
              "id": 339265,
              "key": "fa47cde8-dbfb-4897-b834-ba14e8e92a05",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "你刚创建了一个Pull Request！恭喜！ 🙌🏼  \n\n如你所见，创建 Pull Request 实际上并不难。当我第一次学习 Git、GitHub 以及如何进行协作时，我对提交 commit 和使用远程仓库感到非常紧张，但_尤其_担心向其他开发者的项目提交 Pull Request！只要你遵循上一节课中介绍的步骤：\n\n* 阅读项目的 CONTRIBUTING.md 文件\n* 查看项目现有的 Issues \n* 与项目维护者交流\n\n...你的 Pull Request 一定会被采用！",
              "instructor_notes": ""
            },
            {
              "id": 339266,
              "key": "e4bcad56-8eae-42a9-af8c-7056db0a953b",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## 小结          \n\nPull Request 是让源仓库拉取你的 commit，并融合在其项目中的**请求**。要创建 Pull Request，你需要完成一些操作：\n\n* 你必须 **fork** 源仓库\n* 将你的 fork 克隆到你的计算机\n* 进行一些 commit（最好是在特性分支上！）\n* 将 commit 推送回**你的 fork**\n* 创建一个新的 Pull Request，并选择包含你的新 commit 的分支",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 339325,
          "key": "48825e17-72c6-4c3e-9c98-1add66bf1c86",
          "title": "与源项目保持同步",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "48825e17-72c6-4c3e-9c98-1add66bf1c86",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 339267,
              "key": "76c48385-b2b0-48ce-ba2f-f98d1348f57f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "当你在对仓库进行更改的特性分支上工作时，该仓库可能会从原作者处接收更新。\n\n## Star（收藏）和 Watch（关注）\n\n如果你想跟进仓库的动态，GitHub 提供了一个非常方便的方式 - 它能让你 star 仓库：",
              "instructor_notes": ""
            },
            {
              "id": 339268,
              "key": "36312520-fe97-43d6-a05b-eb31a2d0f82b",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/April/58fe7831_ud456-l3-03-starred-repos/ud456-l3-03-starred-repos.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/36312520-fe97-43d6-a05b-eb31a2d0f82b",
              "caption": "_Star 按钮和仓库的级别_",
              "alt": null,
              "width": 2488,
              "height": 1804,
              "instructor_notes": null
            },
            {
              "id": 339269,
              "key": "164240b7-1e6e-4ce3-93e6-c6d10b8612e9",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "你可以前往 [https://github.com/stars](https://github.com/stars) 列出和过滤你 star 过的所有仓库。\n\n如果你想跟踪特定仓库，star 非常有用。但是，如果你想实时跟进仓库的发展就不行了，你得手动前往收藏页面查看仓库，以检查它们是否发生变化。",
              "instructor_notes": ""
            },
            {
              "id": 339270,
              "key": "25aec41d-867b-4c52-a337-c028c27e1018",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "> ## 💡 Star 和受欢迎度 💡 \n\n> Star 是能帮助你跟踪感兴趣仓库的一个有用功能，同时也成为了衡量仓库受欢迎程度的手段。\n\n> 如果你对提升仓库的星级不感兴趣，不如了解一下 \"watch\" 仓库。现在就在看看吧！",
              "instructor_notes": ""
            },
            {
              "id": 339271,
              "key": "ec67a777-ade4-432d-b157-e9e1881c8bb2",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Watch 仓库\n\n如果你要跟进一个项目的变化，并希望接收变更通知，GitHub 为你提供了 \"Watch\" 功能：",
              "instructor_notes": ""
            },
            {
              "id": 339272,
              "key": "48779c51-3415-43aa-b5fe-e86ab9d080ef",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/April/58fe792c_ud456-l3-03-watched-repos/ud456-l3-03-watched-repos.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/48779c51-3415-43aa-b5fe-e86ab9d080ef",
              "caption": "_通知设置页。\"Watching\" 一个仓库会通知你仓库的所有活动。_",
              "alt": null,
              "width": 2488,
              "height": 1804,
              "instructor_notes": null
            },
            {
              "id": 339273,
              "key": "8e0eb746-a3cd-4a42-acaf-42f23582776f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "如果你频繁地在一个仓库上工作，那么我建议你将 watch 设置改为\"Watching\"（持续关注）。这样，当该仓库发生任何活动时，GitHub 都会通知你，例如当有人向仓库推送变更，创建了新的 Issues，或者在现有 Issues 中添加了评论。\n\n## 加入上传更改\n\n现在你了解了 watch 仓库的好处，假设你在 watch 一个仓库，这时收到一个通知说有一些 commit 被推送到了初始源仓库。你如何让这些更改进入你 fork 的仓库副本中？如果你想继续在你的 fork 上进行开发，那么就需要让你 fork 的副本尽可能与源仓库保持同步。\n\n来看看如何让这些变更从远程仓库进入我们自己的仓库。        instructor_notes: ''",
              "instructor_notes": ""
            },
            {
              "id": 339274,
              "key": "80ab8111-2bf9-4c30-98b7-dda3a4cb9d96",
              "title": "L3 - 包含上游更改",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "VvoC6hN6FjU",
                "china_cdn_id": "VvoC6hN6FjU.mp4"
              }
            },
            {
              "id": 339275,
              "key": "09d31170-e300-435e-aed4-262d2ba163d7",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "假使 Lam 开始对她的项目进行更改了，我的 fork 中不会获得这些更改，我要将她的项目添加为额外远程仓库，以便与她保持同步。 \n\n在我的本地仓库中，我已经有一个远程仓库了，那就是 `origin`。 ",
              "instructor_notes": ""
            },
            {
              "id": 339276,
              "key": "fc74e87f-ac23-464a-bd17-bd8921b14b2a",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/April/58ffad47_ud456-l3-03-git-remotes-origin/ud456-l3-03-git-remotes-origin.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/fc74e87f-ac23-464a-bd17-bd8921b14b2a",
              "caption": "_终端显示了与远程仓库的现有连接。这是我的简写名为 `origin` 的远程仓库。_",
              "alt": null,
              "width": 1578,
              "height": 468,
              "instructor_notes": null
            },
            {
              "id": 339277,
              "key": "31f98264-5422-4db7-9baf-58f3958462b3",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "注意 `origin` 一词只是第一次 `git clone` 远程仓库时使用的**默认**名称。我们将使用 `git remote` 命令来向此列表**添加一个新的**简写名和 URL。这会提供给我们一个与源仓库之间的连接。\n\n```bash\n$ git remote add upstream https://github.com/udacity/course-collaboration-travel-plans.git\n```\n\n注意我使用名称 `upstream` 作为引用源仓库的简写名。与 `origin` 简写名一样，这里的 `upstream` 一词也并不特别；这只是一个常规的词。它可以是任何词... 比如 \"banana\"。但 \"upstream\" 一词通常用于引用源仓库。 \n\n我们来看看在添加了新的远程仓库后，远程仓库的列表现在是什么样的：",
              "instructor_notes": ""
            },
            {
              "id": 339278,
              "key": "20480517-b24c-4a93-a14e-58467ff65116",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/April/58ffae1a_ud456-l3-03-add-upstream-remote/ud456-l3-03-add-upstream-remote.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/20480517-b24c-4a93-a14e-58467ff65116",
              "caption": "_终端显示了关于这两个远程仓库的信息 - `origin` 和 `upstream`。_",
              "alt": null,
              "width": 1578,
              "height": 534,
              "instructor_notes": null
            },
            {
              "id": 339279,
              "key": "d9b8b8ae-94de-4c09-9cc8-79a2f05b0de5",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Origin 与 Upstream 差别\n\n现在令人困惑的一点可能是 `origin` 与 `upstream` 之间的差别。其中，`origin` 指的**不是**我们 fork 自的源仓库（也称为**\"初始\"**仓库），而是指我们 fork 后的仓库。虽然它叫 `origin`，但实际并不是初始仓库。\n\n记住，`origin` 和 `upstream` 只是默认或实际名称。如果你觉得将 `origin` 远程仓库命名为 `mine`，`upstream` 远程仓库命名为 `source-repo` 对你来说更清楚，那么你尽可如此命名。你在本地仓库如何命名远程仓库完全不影响源仓库。",
              "instructor_notes": ""
            },
            {
              "id": 339280,
              "key": "82a1122b-4eea-476f-bebf-607e6ae54291",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/April/58ffae73_ud456-l3-03-rename-repos/ud456-l3-03-rename-repos.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/82a1122b-4eea-476f-bebf-607e6ae54291",
              "caption": "_使用 `git remote rename` 命令将 `origin` 重命名为 `mine`，以及将 `upstream` 重命名为 `source-repo`。_",
              "alt": null,
              "width": 1578,
              "height": 600,
              "instructor_notes": null
            },
            {
              "id": 339281,
              "key": "a2073b15-ed95-494d-b6c2-46e7fe48f189",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "> ## ⚠️ 重置远程仓库名称 ⚠️ \n\n> 上面的图显示了远程仓库的重命名，但我已经使用以下命令将它们变回了默认/实际名称 `origin` 和 `upstream`：\n\n> ```bash\n$ git remote rename mine origin\n$ git remote rename source-repo upstream\n```",
              "instructor_notes": ""
            },
            {
              "id": 339282,
              "key": "3d4e1516-1a21-4dc2-8073-20a75feea9ba",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## 拉取上游变更\n\n现在，要获得上游远程仓库的更改，我们只需运行 `git pull` 并使用 `upstream` 简写名，而不是 `origin` 简写名：\n\n```bash\n$ git pull upstream master\n```",
              "instructor_notes": ""
            },
            {
              "id": 339283,
              "key": "de0df242-f98a-48fd-ae43-8830688c7712",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/April/58ffb75c_ud456-l3-03-fetch-upstream-changes/ud456-l3-03-fetch-upstream-changes.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/de0df242-f98a-48fd-ae43-8830688c7712",
              "caption": "_终端显示了运行 `git fetch upstream master` 的结果。一个新的分支添加到了本地仓库。_",
              "alt": null,
              "width": 1194,
              "height": 501,
              "instructor_notes": null
            },
            {
              "id": 339284,
              "key": "83130709-9151-4d47-be32-a6fd3642bb45",
              "title": "",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "83130709-9151-4d47-be32-a6fd3642bb45",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "现在你已向新的 `upstream` 远程仓库添加了一个连接，如果你运行 `git fetch upstream master`，它会更新你在 GitHub 上 **fork 的仓库**吗？",
                "answers": [
                  {
                    "id": "a1493148150986",
                    "text": "是",
                    "is_correct": false
                  },
                  {
                    "id": "a1493148182704",
                    "text": "否",
                    "is_correct": true
                  }
                ]
              }
            },
            {
              "id": 339285,
              "key": "38d3a369-88b2-455d-9b0a-9410bbdc8b2c",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "现在，我们已从上游远程仓库获取了所有更改，接下来查看日志，看看我们的本地仓库中有哪些新信息。我使用 `git log` 命令来确保显示所有分支的**所有** commit（包括远程和跟踪分支！）：\n\n```bash\n$ git log --oneline --graph --decorate --all\n```",
              "instructor_notes": ""
            },
            {
              "id": 339286,
              "key": "9c008dee-3ebd-4d4f-9d8e-f7efca695589",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/April/58ffb7d1_ud456-l3-03-git-log-of-upstream-changes/ud456-l3-03-git-log-of-upstream-changes.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/9c008dee-3ebd-4d4f-9d8e-f7efca695589",
              "caption": "_终端在获取 `upstream` 远程仓库的变更后，显示了我的本地仓库的日志。_",
              "alt": null,
              "width": 1626,
              "height": 633,
              "instructor_notes": null
            },
            {
              "id": 339287,
              "key": "0035b77a-fc0f-47b2-ae7a-c7ee5ed25525",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "在提交说明的包裹下阅读可能有点困难，但你应该能看到，现在本地 `master` 分支前有一个 `upstream/master` 远程分支。`upstream/master` 位于 commit `52e493f` 上，而 `master` 分支位于 commit `1c12194` 上。 \n\n我们可以使用 `upstream/master` 分支来跟踪源仓库 master 分支的位置。现在，我们可以运行 `git fetch upstream master`，获取对源仓库的`master`分支所做的更改。",
              "instructor_notes": ""
            },
            {
              "id": 339288,
              "key": "3cdd8858-156e-4232-957a-d3154151a475",
              "title": "",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "3cdd8858-156e-4232-957a-d3154151a475",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "使用 `git fetch upstream master` 命令拉取了 `upstream` 远程仓库的 `master` 分支上的更改。\n\n如果我们想获取 `upstream/master` 更改**并**将它们合并到`master`分支，我们应使用什么命令？",
                "matchers": [
                  {
                    "expression": "git pull upstream"
                  },
                  {
                    "expression": "git pull upstream master"
                  }
                ]
              }
            },
            {
              "id": 339289,
              "key": "4ef786ab-256e-4193-b87c-8330f61d2571",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "要向 Lam 的仓库推送这些新更改，我们不想运行 `git push origin upstream/master`，因为 `upstream/master` 不是本地分支。要将这些更改融入我 fork 的她的项目版本，我可以将 `upstream/master` 合并到一个现有分支中（例如本地 `master` 分支）然后推送它。",
              "instructor_notes": ""
            },
            {
              "id": 339290,
              "key": "66f3b024-5606-47fc-a88f-cb9ad6097b42",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "```bash\n# 确保我位于正确的合并分支上\n$ git checkout master\n\n# 合并 Lam 的更改\n$ git merge upstream/master\n\n# 将 Lam 的更改发送到*我的*远程仓库\n$ git push origin master\n```",
              "instructor_notes": ""
            },
            {
              "id": 339291,
              "key": "e1fa4d15-7bd8-49bc-a3b1-306aa1fe649b",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## 小结\n当在你 fork 的项目副本上工作时，初始项目的维护者会继续向他们的项目添加更改。你需要将你的 fork 副本与他们的项目保持同步，以包含他们所做的任何更改。\n\n要将源仓库的更改提取到你在 GitHub 上 fork 的仓库副本，你需要：\n\n* 获得源仓库的可克隆 URL  \n* 使用 `git remote add` 命令创建一个新的远程仓库\n    - 使用简写名 `upstream` 指向源仓库\n    - 提供源仓库的 URL\n* 获取新的 `upstream` 远程仓库\n* 将 `upstream` 的分支合并到本地分支\n* 将新更新的本地分支推送到你的 `origin` 仓库",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 339326,
          "key": "adbf1b90-e1c6-4502-8856-d5207bff78b5",
          "title": "管理活跃 PR",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "adbf1b90-e1c6-4502-8856-d5207bff78b5",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 339292,
              "key": "70b9b211-f856-40ed-94c0-019230daa57a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "项目维护者可能不会立即决定接受你的更改。他们可能会要求你对代码做一些额外更改，才会接受你的请求并合并你的更改。他们很可能会通过 Pull Request 页面的 Conversation（对话）传达他们想要的更改。",
              "instructor_notes": ""
            },
            {
              "id": 339293,
              "key": "0c35a392-5bdb-4ed6-ba1f-874420db2cc6",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/April/58fe8556_ud456-l3-04-pull-request-comment/ud456-l3-04-pull-request-comment.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/0c35a392-5bdb-4ed6-ba1f-874420db2cc6",
              "caption": "_项目维护者要求对 Pull Request 进行一些更改。_",
              "alt": null,
              "width": 2722,
              "height": 1808,
              "instructor_notes": null
            },
            {
              "id": 339294,
              "key": "56cd73ac-c17b-40b9-a6bb-0491fec33acf",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "可以看到源仓库的所有者进行了评论，并要求我们将 commit 结合在一起。\n\n我越来越喜欢 Git 命令行工具和 GitHub 界面的一个原因在于，它们会提供下一步操作的建议，这非常有帮助。在评论区底部附近，GitHub 有一个建议，告诉我们如何添加更多的 commit；我们需要将它们添加到同一个分支并推送到我的分支：\n\n> Add more commits by pushing to the **include-richards-destinations** branch on **richardkalehoff/course-collaboration-travel-plan**.",
              "instructor_notes": ""
            },
            {
              "id": 339295,
              "key": "146d0073-6ea6-496f-94eb-f356e6c87acd",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "在提交 Pull Request 时，记住你是要其他开发者将**你的**代码更改添加到他们的项目。如果他们要求你对你的 Pull Request 做一些小的（甚至是大的！）更改，这并不代表他们拒绝你的工作！只是他们希望以特定方式将你的代码添加到他们的项目中。\n\n你应按照 CONTRIBUTING.md 文件列出项目维护者所需的所有信息，所以请遵照其中的信息。但有时项目维护者可能会要求你做一些其他事情。\n\n那你该怎么做呢？如果你希望你的 Pull Request 被接受，那就执行要求的更改！记住，GitHub 中的选项卡称为\"Conversation（对话）\"选项卡。所以随时与项目维护者进行沟通，以明确他们希望你做什么。\n\n你也应感谢他们花时间查看你的 Pull Request。大多数开源项目的开发者都是在免费做这些事情，所以记住：\n\n* 善待他人 - 项目维护者只是像你一样的普通人\n* 耐心 - 他们会尽快回复",
              "instructor_notes": ""
            },
            {
              "id": 339296,
              "key": "eaa55cf0-1669-44b5-87fd-12ffadc11d45",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Lam 要求我将我的更改结合在一起，之后她才会合并我的 Pull Request。将 commit结合在一起是一个称为压制的过程。我们来看看怎么做！",
              "instructor_notes": ""
            },
            {
              "id": 339297,
              "key": "adb65081-2d11-49b9-8120-f9eb05fb4f28",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## 小结\n\n就像看起来那么简单，主动发起 commit 请求主要在于沟通！\n\n如果项目维护者要求更改 Pull Request，则：\n\n* 在你的 Pull Request 所基于的本地仓库的同一分支上添加一些必要 commit\n* 将该分支推送到**你的**源仓库 fork 副本\n\n这些 commit 最终将显示在 Pull Request 页面上。",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 339327,
          "key": "3d9fb9c8-47bc-4dbd-a6d3-09b006be24e4",
          "title": "压制 commit",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "3d9fb9c8-47bc-4dbd-a6d3-09b006be24e4",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 339298,
              "key": "55b4bce4-914e-4331-b75a-254aea2efb67",
              "title": "L3 - 压制介绍",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "mRbeT2XVL9w",
                "china_cdn_id": "mRbeT2XVL9w.mp4"
              }
            },
            {
              "id": 339299,
              "key": "b3d71bbe-4fc1-473b-8f0c-6601a01b829d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "要将 commit 压制在一起，我们要使用非常强大的 `git rebase` 命令。这是我**最爱的**命令之一，但我的确用了**很久**才掌握它。起初，我很难搞清楚它的工作原理，然后（在网上读了无数警告之后），我开始害怕实际使用它，因为担心它会不可逆转地破坏我的项目的 Git 历史。\n\n但是现在我想告诉你，`git rebase` 实际并没有那么难，你可以勇敢地对你的仓库进行更改，而无需担心造成任何损害！（<-- 听起来相当鼓舞人心，对不对？！）我们首先概述一下压制的工作原理，然后将实际使用 `git rebase` 命令进行一些压制。",
              "instructor_notes": ""
            },
            {
              "id": 339300,
              "key": "34e4b2aa-52e3-4755-a4fd-6c89d950d9fc",
              "title": "L3 - 压制理论",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "H5JqcdIB5y0",
                "china_cdn_id": "H5JqcdIB5y0.mp4"
              }
            },
            {
              "id": 339301,
              "key": "40827622-0a26-405d-b683-e9b999c1bccc",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "我使用的命令是：\n\n```bash\n$ git rebase -i HEAD~3\n```\n## rebase 命令\n\n`git rebase` 命令会将 commit 移动到一个**新基底（base）**上。在命令 `git rebase -i HEAD~3` 中，我们告诉 Git 使用 `HEAD~3` 作为其他所有 commit （`HEAD~2`、`HEAD~1` 和 `HEAD`）将连接到的基底。\n\n命令中的 `-i` 代表\"交互式\"。你_可以_在非交互模式下执行 rebase。在你学习如何 rebase 时，我明确建议你进行_交互式_ rebase。\n### 祖先引用\n\n简短回顾一下，`HEAD` 表示你当前的位置（它可以指向多个东西，但通常会指向分支名称或直接指向一个 commit 的 SHA）。这里的 `~3` 指\"三个之前\"，所以 `HEAD~3` 将是你当前所在的 commit 向前三个的 commit。我们将在 `git rebase` 命令中使用对 commit的这种相对引用。\n\n我来演示一下如何使用此命令将三个目标 commit 组合成一个。",
              "instructor_notes": ""
            },
            {
              "id": 339303,
              "key": "235f2fa7-47ee-48d1-ad8c-a6fee8a61919",
              "title": "L3 - 压制操作",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "cL6ehKtJLUM",
                "china_cdn_id": "cL6ehKtJLUM.mp4"
              }
            },
            {
              "id": 339302,
              "key": "ce4722f0-fcb4-4db7-8c8c-1f15d5b35cf3",
              "title": "",
              "semantic_type": "CheckboxQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "ce4722f0-fcb4-4db7-8c8c-1f15d5b35cf3",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "在该命令中：\n\n```bash\n$ git rebase -i HEAD~3\n```\n\n`HEAD~3` 是即将被变基的 commit 的新基底的祖先引用。\n\n以下哪项可以作为基底引用？",
                "answers": [
                  {
                    "id": "a1493144164979",
                    "text": "SHA",
                    "is_correct": true
                  },
                  {
                    "id": "a1493144244997",
                    "text": "分支名称",
                    "is_correct": true
                  },
                  {
                    "id": "a1493144253355",
                    "text": "标签名称",
                    "is_correct": true
                  }
                ]
              }
            },
            {
              "id": 339304,
              "key": "1b87749b-82b2-4202-9410-5c09f03b1689",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### 强制推送\n\n在此视频中，我必要要强行推送分支。我不得不这样做，因为 GitHub 试图阻止我意外删除 commit。因为我使用了 `git rebase` 命令，实际上**清除**三个分别记录我添加了佛罗里达、巴黎和苏格兰的 commit。我使用 `git rebase` 将这些 commit 合并或**压制**为单个 commit。\n\n使用 `git rebase` 会创建一个具有新 SHA 的新 commit。当我尝试使用 `git push` 将此 commit 推送至 GitHub 时，GitHub 知道接受此推送会删除那三个单独 commit，所以它拒绝了。因此，我不得不使用 `git push -f` **强制推送**这些 commit。",
              "instructor_notes": ""
            },
            {
              "id": 339305,
              "key": "fd398816-cbab-4bd6-8109-25a296cb59de",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "> ### ⚠️ 强行推送 ⚠️ \n\n> 在这个例子中，强行推送我的 commit 非常必要。如果你尝试推送 commit 而 GitHub 拒绝了它们，这实际上是对你的一种帮助，确保你已经审查过正在推送的 commit **和** GitHub 上的 commit，以验证你不会意外覆盖你在远程仓库上存储的内容！",
              "instructor_notes": ""
            },
            {
              "id": 339306,
              "key": "5c549443-06ea-4591-8b80-8b75c1abd4da",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## rebase 命令\n\n来看看你可以使用 `git rebase` 执行哪些不同的命令：\n\n* 使用 `p` 或 `pick` – 使 commit 保持原样\n* 使用 `r` 或 `reword` – 保留 commit 的内容，但修改 commit 说明\n* 使用 `e` 或 `edit` – 保留 commit 的内容，但先不要执行 commit，以便：\n    - 添加新内容或文件\n    - 删除内容或文件\n    - 修改即将 commit 的内容 \n* 使用 `s` 或 `squash` – 将此 commit 的更改结合到之前的 commit 中（列表中位于其上面的 commit ）\n* 使用 `f` 或 `fixup` – 将此 commit 的更改结合到前一个 commit 中，但删除提交说明\n* 使用 `x` 或 `exec` – 运行 shell 命令\n* 使用 `d` 或 `drop` – 删除 commit",
              "instructor_notes": ""
            },
            {
              "id": 339307,
              "key": "e4316542-7573-412e-92ab-3beb35065b61",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## 何时变基\n\n可以看到，`git rebase` 命令非常强大。它可以帮助你编辑提交说明、重新排序 commit、合并 commit 等，真的是一款非常强大的工具。现在的问题是\"应该**何时**进行变基？\"。 \n\n每当你对 commit 进行变基，Git 将**为每个 commit** 创建一个新的 SHA！这有很大的影响。对于 Git，SHA 为 commit 的标识符，因此不同的标识符代表着不同的 commit，**无论内容是否发生了变化。** \n\n如果你已推送了你想进行变基的 commit，则不应变基。如果你在与其他开发者协作，那么他们可能已经在使用你推送的 commit。如果你随后使用 `git rebase` 来进行更改，并强行推送 commit，则其他开发者现在将无法与远程仓库同步。他们需要对自己的 Git 仓库进行一些复杂的手术，使它们的仓库回到工作状态……甚至可能连这一点都做不了；他们可能得抛弃之前的所有工作，使用你新变基过且强制推送的 commit 重新开始。",
              "instructor_notes": ""
            },
            {
              "id": 339308,
              "key": "af0247b0-56a1-44fd-9001-63ce2cc6ad96",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## 小结\n\n`git rebase` 命令可以用来做很多事情。\n\n```bash\n# 交互式 rebase\n$ git rebase -i <base>\n\n# 交互式地将 commit 变基到我们当前所在的 commit 向前三个的 commit\n$ git rebase -i HEAD~3\n```\n\n在 commit 的交互式列表中，所有 commit 都以 `pick` 开头，但你可以使用其他命令（`reword`、`edit`、`squash`、`fixup`、`exec` 和 `drop`）进行变换。\n\n我建议你在变基**之前**创建一个备份（backup）分支，这样便能很容易返回到之前的状态。如果你对变基的结果满意，则可以删除 `backup` 分支！\n\n### 进一步研究\n* Git 分支 - 变基：[英](https://git-scm.com/book/en/v2/Git-Branching-Rebasing)|[中](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA)：来自 GitBook\n* [git-rebase](https://git-scm.com/docs/git-rebase)：来自 Git 文档 (**英**)\n* [https://www.atlassian.com/git/tutorials/rewriting-history#git-rebase](https://www.atlassian.com/git/tutorials/rewriting-history#git-rebase)：来自 Atlassian 博客 (**英**)",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 339328,
          "key": "168d2c0e-4ae3-4c6b-a704-1ed321e53c42",
          "title": "总结",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "168d2c0e-4ae3-4c6b-a704-1ed321e53c42",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 339309,
              "key": "f7d960ab-99a9-4167-a5d6-12206764dd3f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "我简要地整理一下你在此课程中学到的所有非常棒的新技能。现在，你已经知道：\n\n* 如何设置远程仓库\n* 如何将更改推送到远程仓库并从中获取更改\n* 如何 fork 仓库\n* 开始处理新功能或项目更改前，要采取的初步步骤\n* 如何创建 Pull Request\n* 了解与项目其他利益相关者清楚、频繁沟通的重要性",
              "instructor_notes": ""
            },
            {
              "id": 339310,
              "key": "2db6b305-f5b4-4448-894d-f50d76dfea87",
              "title": "课程总结",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "66Ut8Bv6kgc",
                "china_cdn_id": "66Ut8Bv6kgc.mp4"
              }
            },
            {
              "id": 339311,
              "key": "3f5c8514-1c02-432e-97a0-c96be69eaf17",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "* [http://up-for-grabs.net/ (英)](http://up-for-grabs.net/#/)\n* [http://www.firsttimersonly.com/ (英)](http://www.firsttimersonly.com/)\n* [GitHub 上的（仅）初学者标签 (英)](https://github.com/search?utf8=%E2%9C%93&q=label%3Afirst-timers-only+is%3Aopen&type=Issues&ref=searchresults)\n* [\"仅初学者\"博文 (英)](https://medium.com/@kentcdodds/first-timers-only-78281ea47455)\n* [Git Community Book 中文版](http://gitbook.liuhui998.com/index.html)\n* git-tips: [英文版](https://github.com/git-tips/tips) | [中文版](https://github.com/521xueweihan/git-tips)\n\n想看看开发者的第一个 Pull Request 是什么？查看 [http://firstpr.me/](http://firstpr.me/)",
              "instructor_notes": ""
            }
          ]
        }
      ]
    }
  },
  "_deprecated": [
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    }
  ]
}