WEBVTT
Kind: captions
Language: zh-CN

00:00:00.300 --> 00:00:02.710
要按日期分组的话

00:00:02.710 --> 00:00:07.570
我们需要把 2017 年 4 月 1 日这一天所有的时间

00:00:07.570 --> 00:00:16.600
调整成 2017-04-01 00:00:00 

00:00:16.600 --> 00:00:20.530
按日期分组时 我们会得到

00:00:20.530 --> 00:00:22.375
4 月1 日所有小时、分钟和秒内发生的每一个事件

00:00:22.375 --> 00:00:26.923
它们会被归为一组

00:00:26.922 --> 00:00:30.292
我们可以用 DATE_TRUNC 函数来完成这个

00:00:30.292 --> 00:00:35.429
我们现在开始按 occurred_at 分组 中间不要有任何截断

00:00:35.429 --> 00:00:39.484
如你所见 这对我们根本没有什么用

00:00:39.484 --> 00:00:43.475
如果我们用被截断的版本来替换 occurred_at 的每个实例

00:00:43.475 --> 00:00:53.875
我们会得到一个结果集 按天汇总了标准纸张的数量

00:00:53.875 --> 00:00:56.369
要按包含在 SELECT 语句中的相同度量进行分组 这一点非常重要

00:00:56.369 --> 00:00:59.640
这样可以保证你的结果是一致的

00:00:59.640 --> 00:01:02.310
在一些数据库中 可以用 'year' 来进行分组

00:01:02.310 --> 00:01:06.210
然后在 SELECT 语句中 用 'day' 截断

00:01:06.209 --> 00:01:07.799
但是大多数人只能偶尔这么做

00:01:07.799 --> 00:01:10.664
因为这样产生的结果会令人困惑

00:01:10.665 --> 00:01:14.895
在很多情况下 你试图回答的问题类型是错误的

00:01:14.894 --> 00:01:17.325
要确保你分组正确 最简单的方法就是

00:01:17.325 --> 00:01:21.469
用列号而不需重新输入某个准确的函数

00:01:21.469 --> 00:01:26.609
DATE_TRUNC 可以按照更为细粒度的级别进行聚合 如 SECOND

00:01:26.609 --> 00:01:28.019
如果你正在使用服务器日志 这可能会有用

00:01:28.019 --> 00:01:30.989
但许多事件发生在给定的秒内

00:01:30.989 --> 00:01:32.234
虽然大部分时间

00:01:32.234 --> 00:01:36.215
你会使用时间间隔进行聚合 因为它从业务角度来看很有意义

00:01:36.215 --> 00:01:39.344
比如 'day'、 'week'、 'month'、 'quarter'、 'year'

00:01:39.344 --> 00:01:42.094
在这里 我们可以看到不同的截断

00:01:42.094 --> 00:01:45.420
需要注意的是 如果我们的 'month' 或 'day' 是 01

00:01:45.420 --> 00:01:49.724
你可以看到 这些值没有改变

00:01:49.724 --> 00:01:54.884
在某些情况下 你可能只需要提取一个日期的某一部分

00:01:54.885 --> 00:01:57.210
例如 如果你想知道

00:01:57.209 --> 00:01:59.744
本周哪一天中 Parch &amp; Posie 网站的流量最大

00:01:59.745 --> 00:02:01.837
但你不想使用 DATE_TRUNC

00:02:01.837 --> 00:02:03.245
要想知道具体是哪一天

00:02:03.245 --> 00:02:05.215
你必须使用 DATE_PART

00:02:05.215 --> 00:02:09.439
DATE_PART 可以让你提取出你感兴趣的日期中的某个部分

00:02:09.439 --> 00:02:11.794
但是请注意 无论是哪一年

00:02:11.794 --> 00:02:14.309
一个 DATE_PART 将会提取出

00:02:14.310 --> 00:02:17.750
发生在 2016 年 4 月与 2017 年 4 月 的事件

00:02:17.750 --> 00:02:20.893
DATE_TRUNC 会区分这些事件

00:02:20.893 --> 00:02:24.300
让我们用 Parch &amp; Posie 的数据来套用一下这个例子

00:02:24.300 --> 00:02:26.844
一周中的哪一天销售额最多？

00:02:26.844 --> 00:02:29.900
首先 我们要确认每周每天的订单

00:02:29.900 --> 00:02:32.580
DOW 代表星期几

00:02:32.580 --> 00:02:34.860
会返回一个从 0 到 6 的值

00:02:34.860 --> 00:02:37.885
其中 0 代表星期日 6 代表星期六

00:02:37.884 --> 00:02:39.539
现在我们有了这一栏数据

00:02:39.539 --> 00:02:43.854
我们可以通过汇总来计算哪一天销售的纸张最多

00:02:43.854 --> 00:02:47.259
我们将按总和降序排列

00:02:47.259 --> 00:02:52.289
销售额最高的一天会出现在结果集的顶部

00:02:57.889 --> 00:03:01.449
看来星期天的纸张订单最大

00:03:01.449 --> 00:03:04.369
星期四的纸张订单最小

