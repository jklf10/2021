WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.640
假设你是 Parch &amp; Posey 的账户经理

00:00:02.640 --> 00:00:05.445
负责的是公司最大的账户

00:00:05.445 --> 00:00:08.730
你可能需要确定销售额超过 25 万的帐户的总销售额

00:00:08.730 --> 00:00:11.400
以便更好地了解

00:00:11.400 --> 00:00:14.475
来自这些大额账户的收入的比例

00:00:14.474 --> 00:00:19.129
要得到这个清单 我们首先要知道每个帐户的销售总额

00:00:19.129 --> 00:00:20.789
按降序排列

00:00:20.789 --> 00:00:25.119
我们可以看到结果集顶部的所有最高值账户

00:00:25.120 --> 00:00:30.285
现在 我们要从这些账户中过滤出销售额超过 25 万的帐户

00:00:30.285 --> 00:00:38.835
你会注意到 WHERE 子句并不是完全为此而构建的

00:00:38.835 --> 00:00:42.769
WHERE 子句不会用与此处

00:00:42.770 --> 00:00:46.592
因为它不允许你过滤聚合列

00:00:46.591 --> 00:00:49.320
而聚合列要用到 HAVING 子句

00:00:49.320 --> 00:00:52.409
HAVING 子句总是出现在

00:00:52.409 --> 00:01:03.037
GROUP BY 语句后面

00:01:03.037 --> 00:01:11.655
你还会注意到 你会一直用到 GROUP BY 语句

00:01:11.655 --> 00:01:16.965
因为 HAVING 总是要与一个聚合函数一起使用

00:01:16.965 --> 00:01:20.790
通过这种查询 可以过滤出

00:01:20.790 --> 00:01:24.690
销售额超过 25 万的账户

00:01:24.689 --> 00:01:26.024
你需要记住一点

00:01:26.025 --> 00:01:30.450
这只有在按一个或多个列分组时才有用

00:01:30.450 --> 00:01:33.045
如果你正在聚合整个数据集

00:01:33.045 --> 00:01:35.120
那么输出只有一行

00:01:35.120 --> 00:01:37.120
所以没有必要进行过滤

